kubernetes Architecture 	
	The architecture of k8s differs from master and worker node 

	Master node components 
		1. Api Server / kube-api-server
			- It is the main management point of the cluster and also called 
			  as brain of the cluster.
			- All the components are directly connected to API serve, they 
			  communicate through API server only and no other component will 
			  communicate directly with each other.
			- This is the only component which connects and got access to etcd.
			- All the cluster requests are authenticated and authorised by API server.
			- API server has a watch mechanism for watching the changes in cluster.
			
		2. etcd 
			- ectd is a distributed , consistent key value store used for 
			  storing the complete cluster information/data.
			- ectd contains data such as configuration management of cluster,
              distributed work and basically complete cluster information.			
			
		3. scheduler / kube-scheduler
			- The scheduler always watches for a new pod request and 
			  decides which worker node this pod should be created.
			- Based on the worker node load, affinity and anti-affiny, taint configuration 
			  pod will be scheduled to a particular node.
			  
		Controller manager /control manager / kube-controller 
			- It is a daemon that always runs and embeds core control loops known as controllers. 
			- K8s has some inbuild controllers such as Deployment, DaemonSet, ReplicaSet, Replication controller,
			  node controller, jobs, cronjob, endpoint controller, namespace controller etc.	
			
		Cloud controller manager 
			- These controller help us to connect with the public cloud provider service and this component 
			  is maintained by cloud providers only.

	Worker node components 
		kubelet 
			- It is an agent that runs on each and every worker node and it alsways watches the API 
			  server for pod related changes running in its worker node.
			- kubelet always make sure that the assigend pods to its worker node is running.
			- kubelet is the one which communicates with containarisation tool (docker daemon)
              		  through docker API (CRI). 	
			- work of kubelet is to create and run the pods. Always reports the status of the worker node 
			  and each pod to API server. (uses a tool call cAdvisor)
			- Kubelet is the one which runs probes.	
		
		kube service proxy 
			(in k8s service means networking)
			- Service proxy runs on each and every worker node and is responsble for watching API 
			  server for any changes in service configuration (any network related configuration).	
			- Based on the configuration service proxy manages the entire network of worker node.

		Container runtime interface (CRI)
			- This component initialy identifies the container technology and connects it to kubelet.
			
			
		pod
			- pods are the smallest deployable object in kuberntes.
			- pod should contain atleast one container and can have n number of containers.
			- If pod contains more than one container all the container share the same memory assigned to that pod.

Assignment: What happens when a new pod request comes to (control plane / Master node) ? 

YAML file 
	- Filetype .yaml or .yml
	- YAML file container key - value pairs 
	- Key will be defined by the tools (k8s defined)
	- Value will be defined by user.
			Type of value we can is 
				- Interger (Numeric)
				- String (Alphanumeric)
				- Array ( Group of similar)
				- List  ( Group different types of elements)
				- Boolean (True / False)

ex: 	List 
			1) name: Harsha
			   hobbies: ["Driving", "coding", "Reading", "....."]

			   			or
			1) name: Harsha
			   hobbies: 
			   		- Driving
					- coding
					- Reading			

	k8s synatx 

		apiVersion: v1
		kind: Pod
		metadata:
		    name: nginx
			labels:
               environment: production
               app: nginx
		spec:
			containers:
			- name: nginx
				image: nginx:1.14.2
				ports:
				- containerPort: 80

		apiVersion: 
			- Type of api versions in k8s are alpha, beta and stable.
			- vXalphaX, vXbetaX, and vX
			- The is to specify the version of api used to create the kind of k8s object.
		
		kind: 
			- used to specify which type of object we want to create.
			- Always object name first letter is capital.

		metadata: 
			- To provide information on the object we are creating.
			- name, labels, annotations.

		spec: 
			- complete configuration of the object is provided.

pod 
	- pods are the least/smallest deployable object in kubernetes.
	- pod should contain at least one container and can have n number containers.
    - All the containers in a pod will share the same resources.

Deployment / Deployment controller 
	- Deployment is used to create pod replicas (n number of similar kind of pods).
	- At a given point of time Deployment ensures that the specified number of pods is always running.
	- Deployment is a cluster level object.

	- We can scale-up and scale-down the pods any time.
			1. We can change the replicas in spec file.
			2. kubectl scale deployment <deployment_name> --replicas=4 

	- We can configure autoscale of pods using deployment and Deployment got its own autoscaller - HPA (Horizontal pod autoscaller) and VPA (Vertical pod autoscaller)	
			kubectl autoscale deployment <deployment_name> --min=2 --max=10 --cpu-percent=50 --memory=200Mi 
	
	- Deployment internally uses ReplicaSet controller to replicate the pods.
	- Rollout and Rolldown of pod image updates.
			Rollout - Update the app by updating the container image
			Rolldown - Revert/Downgrade the app by downgrading the container image

	Deployment = Pods + ReplicaSet + (Rollout, Rolldown) + (scale-up, scale-down) + autoscaller

Labels, selector and annotations
	Labels:
		- K8S labels are provided as metadata key value to identify the object.
		- We can provide labels to any object in K8S
		- Labels are used to identify by selectors
		- We can have same label on multiple objects and 	

		To list labels of any object 
			kubectl get <object_type> <object_name> --show-labels	

	Selectors:
		- Selectors are used to select, filter and identify the labeled objects.

		Types of selectors 
			equality-based 
				- In this selector we can use only one operator which is equal_to (=, ==) or (!=) not_equal
				- It looks for exact match for the label  

				app = nginx  or app: nginx
				app != nginx

			set-based 
				- This type of selector allows to filter objects based on multiple set of values to a key.
				- operators that are supported are in , notin and exists

				app in (nginx, nginx1)
				app exists (nginx, nginx1)
				app notin (nginx, nginx1)

ReplicaSet vs Replication controller
	- Both ensures that at a given point of time the specified number of replicas are always running.
	- Replication controller is very old controller now it is replaced by ReplicaSet.
	- The only difference between them is Replication controller supports only equality-based selector but 
	  ReplicaSet support both set-based and equality based selector.

DaemonSet 
	- DaemonSet creates exactly one pod on each and every worker node in the cluster and ensures that all that are 
	  always running.
    - If a new worker node is added or deleted, DaemonSet will also add or delete the pod from the 
	  respective worker node.

Service (svc) 
	- Service are cluster level object.
	- By default, service are loadbalancers.
	
	 ClusterIP
		- This is the default type of service in k8S.
		- using ClusterIP we can expose the IPs of pods to another set of pods with in the cluster.

