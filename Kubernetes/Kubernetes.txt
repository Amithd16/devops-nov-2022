kubernetes Architecture 	
	The architecture of k8s differs from master and worker node 

	Master node components 
		1. Api Server / kube-api-server
			- It is the main management point of the cluster and also called 
			  as brain of the cluster.
			- All the components are directly connected to API serve, they 
			  communicate through API server only and no other component will 
			  communicate directly with each other.
			- This is the only component which connects and got access to etcd.
			- All the cluster requests are authenticated and authorized by API server.
			- API server has a watch mechanism for watching the changes in cluster.
			
		2. etcd 
			- ectd is a distributed , consistent key value store used for 
			  storing the complete cluster information/data.
			- ectd contains data such as configuration management of cluster,
              distributed work and basically complete cluster information.			
			
		3. scheduler / kube-scheduler
			- The scheduler always watches for a new pod request and 
			  decides which worker node this pod should be created.
			- Based on the worker node load, affinity and anti-affiny, taint configuration 
			  pod will be scheduled to a particular node.
			  
		Controller manager /control manager / kube-controller 
			- It is a daemon that always runs and embeds core control loops known as controllers. 
			- K8s has some inbuild controllers such as Deployment, DaemonSet, ReplicaSet, Replication controller,
			  node controller, jobs, cronjob, endpoint controller, namespace controller etc.	
			
		Cloud controller manager 
			- These controller help us to connect with the public cloud provider service and this component 
			  is maintained by cloud providers only.

	Worker node components 
		kubelet 
			- It is an agent that runs on each and every worker node and it alsways watches the API 
			  server for pod related changes running in its worker node.
			- kubelet always make sure that the assigend pods to its worker node is running.
			- kubelet is the one which communicates with containarisation tool (docker daemon)
              		  through docker API (CRI). 	
			- work of kubelet is to create and run the pods. Always reports the status of the worker node 
			  and each pod to API server. (uses a tool call cAdvisor)
			- Kubelet is the one which runs probes.	
		
		kube service proxy 
			(in k8s service means networking)
			- Service proxy runs on each and every worker node and is responsble for watching API 
			  server for any changes in service configuration (any network related configuration).	
			- Based on the configuration service proxy manages the entire network of worker node.

		Container runtime interface (CRI)
			- This component initialy identifies the container technology and connects it to kubelet.
			
			
		pod
			- pods are the smallest deployable object in kuberntes.
			- pod should contain atleast one container and can have n number of containers.
			- If pod contains more than one container all the container share the same memory assigned to that pod.

Assignment: What happens when a new pod request comes to (control plane / Master node) ? 

YAML file 
	- Filetype .yaml or .yml
	- YAML file container key - value pairs 
	- Key will be defined by the tools (k8s defined)
	- Value will be defined by user.
			Type of value we can is 
				- Interger (Numeric)
				- String (Alphanumeric)
				- Array ( Group of similar)
				- List  ( Group different types of elements)
				- Boolean (True / False)

ex: 	List 
			1) name: Harsha
			   hobbies: ["Driving", "coding", "Reading", "....."]

			   			or
			1) name: Harsha
			   hobbies: 
			   		- Driving
					- coding
					- Reading			

	k8s syntax 

		apiVersion: v1
		kind: Pod
		metadata:
		    name: nginx
			labels:
               environment: production
               app: nginx
		spec:
			containers:
			- name: nginx
				image: nginx:1.14.2
				ports:
				- containerPort: 80

		apiVersion: 
			- Type of api versions in k8s are alpha, beta and stable.
			- vXalphaX, vXbetaX, and vX
			- The is to specify the version of api used to create the kind of k8s object.
		
		kind: 
			- used to specify which type of object we want to create.
			- Always object name first letter is capital.

		metadata: 
			- To provide information on the object we are creating.
			- name, labels, annotations.

		spec: 
			- complete configuration of the object is provided.

pod 
	- pods are the least/smallest deployable object in kubernetes.
	- pod should contain at least one container and can have n number containers.
    - All the containers in a pod will share the same resources.

Deployment / Deployment controller 
	- Deployment is used to create pod replicas (n number of similar kind of pods).
	- At a given point of time Deployment ensures that the specified number of pods is always running.
	- Deployment is a cluster level object.

	- We can scale-up and scale-down the pods any time.
			1. We can change the replicas in spec file.
			2. kubectl scale deployment <deployment_name> --replicas=4 

	- We can configure autoscale of pods using deployment and Deployment got its own autoscaller - HPA (Horizontal pod autoscaller) and VPA (Vertical pod autoscaller)	
			kubectl autoscale deployment <deployment_name> --min=2 --max=10 --cpu-percent=50 --memory=200Mi 
	
	- Deployment internally uses ReplicaSet controller to replicate the pods.
	- Rollout and Rolldown of pod image updates.
			Rollout - Update the app by updating the container image
			Rolldown - Revert/Downgrade the app by downgrading the container image

	Deployment = Pods + ReplicaSet + (Rollout, Rolldown) + (scale-up, scale-down) + autoscaller

Labels, selector and annotations
	Labels:
		- K8S labels are provided as metadata key value to identify the object.
		- We can provide labels to any object in K8S
		- Labels are used to identify by selectors
		- We can have same label on multiple objects and 	

		To list labels of any object 
			kubectl get <object_type> <object_name> --show-labels	

	Selectors:
		- Selectors are used to select, filter and identify the labeled objects.

		Types of selectors 
			equality-based 
				- In this selector we can use only one operator which is equal_to (=, ==) or (!=) not_equal
				- It looks for exact match for the label  

				app = nginx  or app: nginx
				app != nginx

			set-based 
				- This type of selector allows to filter objects based on multiple set of values to a key.
				- operators that are supported are in , notin and exists

				app in (nginx, nginx1)
				app exists (nginx, nginx1)
				app notin (nginx, nginx1)

ReplicaSet vs Replication controller
	- Both ensures that at a given point of time the specified number of replicas are always running.
	- Replication controller is very old controller now it is replaced by ReplicaSet.
	- The only difference between them is Replication controller supports only equality-based selector but 
	  ReplicaSet support both set-based and equality based selector.

DaemonSet 
	- DaemonSet creates exactly one pod on each and every worker node in the cluster and ensures that all that are 
	  always running.
    - If a new worker node is added or deleted, DaemonSet will also add or delete the pod from the 
	  respective worker node.

Service (svc) (Basic network configurations in k8s)
	- Service is an REST api objects with which we can define policies to access set of pods.
	- Service are cluster level object.
	- By default, services are loadbalancers.
	- K8S Preffered port range for services is between 30000 - 50000.  
	
	ClusterIP
		- This is the default type of service in k8S.
		- using ClusterIP we can expose the IPs of pods to another set of pods with in the cluster.

		To check 
			1. Create a custom images and push to your Docker registry
				docker build -t <username>/<repo_name>:<tag> .
				docker login
				docker push 
			2. kubectl apply -f clusterIP.yml

			3. Login to any one pod
					kubectl exec -it <pod_name> /bin/bash

			4. Try to access the service - ClusterIP using <ClusterIP_ip_address>:<service_port>		 	
				curl </ClusterIP_ip_address>:<service_port>
				ex: (for i in {1..20}; do curl 10.101.209.36:30002; echo; done)

	NodePort
		- This service is most primitive way to get the external traffic directed to our applications 
		  running inside the cluster in pods.
		- Automatically a ClusterIP will also be created internally.

		NodePort = ClusterIP + a port mapping to the all the nodes ips. 		

		- If we wont specify any port while creating nodeport, k8s will Automatically asigns a random port 
		  between 30000 - 32767

	Load Balancer 
		- This service links to external cloud loadbalancers to the cluster.
		- This type of services are used by cloud providers (EKS, AKS, GKS) and it is completely 
		  depends on cloud provides.
		- K8S is providing a better alternative for this service which is called Ingress.

Statefull Applications 
	- User session data is saved at the server side.
	- if server goes down, it is difficult to transfer the session data to other server. 
	- This type of application will not work, if we want to implement autoscaling.
	
Stateless Applications
	- user session-data is never saved at the server side.
	- using a common authentication gateway / client token method to validate the users 
	  once for multiple microservices.	
		
https://medium.com/tech-tajawal/microservice-authentication-and-authorization-solutions-e0e5e74b248a		

Monolothic and Microservice architecture 

	Monolothic architecture
		- A monolothic application has a single code base with multiple modules in it.
		- It is a single build for entire application.
		- To make minor changes to application, we need to re-build and re-deploy the 
		  complete application.
		- scaling is very challenging.
			
	Microservice architecture 
		- A microservice application is composed of small (micro) services. 
		- Each service will have a different code base.
		- Application are divided into as small as possible sub applications called services
		  which are independent to each other which are called loosely coupled.	
		- Each service can be managed separately and it is deployable separately.
		- Services need not to share same technology stack or frameworks.		 

StatefullSet 
	- StatefullSet = Deployment + sticky identity for each and every pod 
	- Unlike a deployemnt a StatefullSet maintains a sticky identity for each and every pod.


Headless service 
	- If we don't need the default loadbalancing capability of services nor the single IP to service we use StatefullSet 
	- using Headless service we can get all the target pod ips, if we do nslookup.
	- It is created by sepcifying 'none' for ClusterIP
	- Headless service is usually used with StatefullSet controller.    

To check app is running 
	telnet 10.102.174.193 30002

namespaces (ns)
	- k8s namespaces is a way of applying abstraction / isolation to support multiple 
	  virtual clusters of k8s objects with in the same physical cluster.
	- Each and every object in k8s must be in a namespace.
	- If we wont specify namespace, objects will be created in default namespace of k8s.
    - namespaces are cluster level.
	- Namespace are only hidden from each other but not fully isolated because one 
	  service in a namespace can talk to another service in another namespace using 
	  fullname (service/<service_name>) followed by namespace name
	
	usage: we can apply environment based logical separation on cluster. 
		
	Type of deafault NS
	1. default
	   - This NS is used for all the objects which are not belongs to any other namespace.
	   - If we wont specify any namespace while creating an object in k8s then 
         that object will be created in deafult namespace.
			
	2. kube-system 
	   - This namespace is always used for objects created by the k8s system.
	   
	3. kube-public 
	   - The objects in this namespace are available or accessable to all.
       - All the objects in this namespace are made public.

	4. kube-node-lease 
	   - This namespace holds lease objects assosiated with each node.
	   - Node lease allows the kubelet to send heartbeats so that the control palne can 
		 detect node failure.

	To list namespaces 
		kubectl get namespaces 
		kubectl get ns	

	To list object in a namespace 
		kubectl get -n <namespace_name> <object_type>
	
	To list objects in all namespaces
		kubectl get --all-namespaces <object_type>
		kubectl get -A <object_type>

	To create a namespace 
		kubectl create ns <namespace_name>
		
	To create a object in a namespace 
		1. In metadata:
			namespace: <namespace_name>

		2. While apply 	
			kubectl apply -f <spec_file>.yml -n <namespace_name> 

		Note: If we provide namespace in both spec file and while apply, 
		      apply command check and compares the namespace in spec file if they are not same k8s won't 
		      allow us to create the object.			
	
Service Discovery (microservice access)
	Questions 
		- How a microservice will communicate with other microservice
		- pod to pod communicate 

	kubectl cluster-info
		to get ip address of our k8s cluster and also CoreDNS address 

	1. Services 
		- we can use the fullname of service to Discovery a microservice (pod)		
			fullname - (service/<service_name>)

	2. DNS 
		- DNS server is added to the cluster by k8s in order to map the service request.
		- When ever we create a service k8s will Automatically create a DNS record for it.
					A - (target always ip address )  CNAME (another DNS) 	
		- Record type A is used in k8s service Discovery and this is created on objects with IP 
			(pods, services) 			

		syntax: 
				mail.google.com 
					.com (top level domain type)
					google (name of the main domain)
					mail (name of the subdomain)	

				K8S DNS 
					<object_name>.<namespace_name>.<object_type>.cluster.local

					ex: my-clusterip-ip-app.default.svc.cluster.local	

	3. K8S ENV 	
		- These are environment variables which k8s auto creates in each and every pod 
		  which is connected to a service 
		- KUBERNETES_SERVICE_PORT_HTTPS=443
		- KUBERNETES_SERVICE_PORT=443
		- KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
		- KUBERNETES_PORT_443_TCP_PROTO=tcp
		- KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
		- KUBERNETES_SERVICE_HOST=10.96.0.1
		- KUBERNETES_PORT=tcp://10.96.0.1:443
		- KUBERNETES_PORT_443_TCP_PORT=443   		 		

kubernetes Volumes 

ConfigMaps and Secrets 
	- ConfigMaps are k8s object that allows us ti separate the configuration data from the 
	  pod configuration. 
	- Using this we can easily inject the environment variables to the pods.
	- ConfigMaps data is not secure and it is readable so better to use for 
	  non-confidential data.

	- Secrets by default data will be encrypted in BASE64 format.


probes
   -  when probe fails it will mark the container to be restarted. To continue running probe checks should end in success.
	  
	  Common fields in probes 
		initialDelaySeconds: After the container has started the number of seconds to wait 
							 before executing the probe.
		periodSeconds: The number of seconds the probe should be executing. (Default 10 secs and min 1 second)
		timeoutSeconds: NUmber of seconds after which probe check timeouts.  (default 1)
		failureThreshold: This is the number of subsequent failures probe should get to mark container to stop. (default 3) 
		successThreshold: This is the number of subsequent success probe should get to mark container to stop. (default 1)

	  EndPoints 
	  	 http probes (httpGet)
			host - hostname to connect (dns / ip) (default is the ip od the pod) (ex: www.google.com)
			path - exact path of the application on the http sever (ex: /mail)
					ex: www.google.com/mail
			port - Name or number of the port to check		
			httpHeaders - can send data in request headers 		
		 TCP probes
			port - Name or number of the port to check.
		 exec 
		 	command - command to execute and check the status.

	Types of probes 
		1) Liveness-probe
			- It will check application endpoint is healthy or not.
			- If Liveness probe fails it will mark the container to be restarted by kubelet.

		Liveness - http
		apiVersion: v1
		kind: pod 
		metadata: 
		     name: liveness-http


		2) Readiness-probe
			- Readiness probe check application running or not and also it checks 
			  application is in a state to accept the traffic or not.	

		3) startupProbe
				- This probe will the one one to run first on container startup.
				- We can use this is give more time to startup an application.
			
