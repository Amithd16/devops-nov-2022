kubernetes Architecture 	
	The architecture of k8s differs from master and worker node 

	Master node components 
		1. Api Server / kube-api-server
			- It is the main management point of the cluster and also called 
			  as brain of the cluster.
			- All the components are directly connected to API serve, they 
			  communicate through API server only and no other component will 
			  communicate directly with each other.
			- This is the only component which connects and got access to etcd.
			- All the cluster requests are authenticated and authorised by API server.
			- API server has a watch mechanism for watching the changes in cluster.
			
		2. etcd 
			- ectd is a distributed , consistent key value store used for 
			  storing the complete cluster information/data.
			- ectd contains data such as configuration management of cluster,
              distributed work and basically complete cluster information.			
			
		3. scheduler / kube-scheduler
			- The scheduler always watches for a new pod request and 
			  decides which worker node this pod should be created.
			- Based on the worker node load, affinity and anti-affiny, taint configuration 
			  pod will be scheduled to a particular node.
			  
		Controller manager /control manager / kube-controller 
			- It is a daemon that always runs and embeds core control loops known as controllers. 
			- K8s has some inbuild controllers such as Deployment, DaemonSet, ReplicaSet, Replication controller,
			  node controller, jobs, cronjob, endpoint controller, namespace controller etc.	
			
		Cloud controller manager 
			- These controller help us to connect with the public cloud provider service and this component 
			  is maintained by cloud providers only.

	Worker node components 
		kubelet 
			- It is an agent that runs on each and every worker node and it alsways watches the API 
			  server for pod related changes running in its worker node.
			- kubelet always make sure that the assigend pods to its worker node is running.
			- kubelet is the one which communicates with containarisation tool (docker daemon)
              		  through docker API (CRI). 	
			- work of kubelet is to create and run the pods. Always reports the status of the worker node 
			  and each pod to API server. (uses a tool call cAdvisor)
			- Kubelet is the one which runs probes.	
		
		kube service proxy 
			(in k8s service means networking)
			- Service proxy runs on each and every worker node and is responsble for watching API 
			  server for any changes in service configuration (any network related configuration).	
			- Based on the configuration service proxy manages the entire network of worker node.

		Container runtime interface (CRI)
			- This component initialy identifies the container technology and connects it to kubelet.
			
			
		pod
			- pods are the smallest deployable object in kuberntes.
			- pod should contain atleast one container and can have n number of containers.
			- If pod contains more than one container all the container share the same memory assigned to that pod.

Assignment: What happens when a new pod request comes to (control plane / Master node) ? 

YAML file 
	- Filetype .yaml or .yml
	- YAML file container key - value pairs 
	- Key will be defined by the tools (k8s defined)
	- Value will be defined by user.
			Type of value we can is 
				- Interger (Numeric)
				- String (Alphanumeric)
				- Array ( Group of similar)
				- List  ( Group different types of elements)
				- Boolean (True / False)

ex: 	List 
			1) name: Harsha
			   hobbies: ["Driving", "coding", "Reading", "....."]

			   			or
			1) name: Harsha
			   hobbies: 
			   		- Driving
					- coding
					- Reading			

	k8s syntax 

		apiVersion: v1
		kind: Pod
		metadata:
		    name: nginx
			labels:
               environment: production
               app: nginx
		spec:
			containers:
			- name: nginx
				image: nginx:1.14.2
				ports:
				- containerPort: 80

		apiVersion: 
			- Type of api versions in k8s are alpha, beta and stable.
			- vXalphaX, vXbetaX, and vX
			- The is to specify the version of api used to create the kind of k8s object.
		
		kind: 
			- used to specify which type of object we want to create.
			- Always object name first letter is capital.

		metadata: 
			- To provide information on the object we are creating.
			- name, labels, annotations.

		spec: 
			- complete configuration of the object is provided.

pod 
	- pods are the least/smallest deployable object in kubernetes.
	- pod should contain at least one container and can have n number containers.
    - All the containers in a pod will share the same resources.

Deployment / Deployment controller 
	- Deployment is used to create pod replicas (n number of similar kind of pods).
	- At a given point of time Deployment ensures that the specified number of pods is always running.
	- Deployment is a cluster level object.

	- We can scale-up and scale-down the pods any time.
			1. We can change the replicas in spec file.
			2. kubectl scale deployment <deployment_name> --replicas=4 

	- We can configure autoscale of pods using deployment and Deployment got its own autoscaller - HPA (Horizontal pod autoscaller) and VPA (Vertical pod autoscaller)	
			kubectl autoscale deployment <deployment_name> --min=2 --max=10 --cpu-percent=50 --memory=200Mi 
	
	- Deployment internally uses ReplicaSet controller to replicate the pods.
	- Rollout and Rolldown of pod image updates.
			Rollout - Update the app by updating the container image
			Rolldown - Revert/Downgrade the app by downgrading the container image

	Deployment = Pods + ReplicaSet + (Rollout, Rolldown) + (scale-up, scale-down) + autoscaller

Labels, selector and annotations
	Labels:
		- K8S labels are provided as metadata key value to identify the object.
		- We can provide labels to any object in K8S
		- Labels are used to identify by selectors
		- We can have same label on multiple objects and 	

		To list labels of any object 
			kubectl get <object_type> <object_name> --show-labels	

	Selectors:
		- Selectors are used to select, filter and identify the labeled objects.

		Types of selectors 
			equality-based 
				- In this selector we can use only one operator which is equal_to (=, ==) or (!=) not_equal
				- It looks for exact match for the label  

				app = nginx  or app: nginx
				app != nginx

			set-based 
				- This type of selector allows to filter objects based on multiple set of values to a key.
				- operators that are supported are in , notin and exists

				app in (nginx, nginx1)
				app exists (nginx, nginx1)
				app notin (nginx, nginx1)

ReplicaSet vs Replication controller
	- Both ensures that at a given point of time the specified number of replicas are always running.
	- Replication controller is very old controller now it is replaced by ReplicaSet.
	- The only difference between them is Replication controller supports only equality-based selector but 
	  ReplicaSet support both set-based and equality based selector.

DaemonSet 
	- DaemonSet creates exactly one pod on each and every worker node in the cluster and ensures that all that are 
	  always running.
    - If a new worker node is added or deleted, DaemonSet will also add or delete the pod from the 
	  respective worker node.

Service (svc) (Basic network configurations in k8s)
	- Service is an REST api objects with which we can define policies to access set of pods.
	- Service are cluster level object.
	- By default, services are loadbalancers.
	- K8S Preffered port range for services is between 30000 - 50000.  
	
	ClusterIP
		- This is the default type of service in k8S.
		- using ClusterIP we can expose the IPs of pods to another set of pods with in the cluster.

		To check 
			1. Create a custom images and push to your Docker registry
				docker build -t <username>/<repo_name>:<tag> .
				docker login
				docker push 
			2. kubectl apply -f clusterIP.yml

			3. Login to any one pod
					kubectl exec -it <pod_name> /bin/bash

			4. Try to access the service - ClusterIP using <ClusterIP_ip_address>:<service_port>		 	
				curl </ClusterIP_ip_address>:<service_port>
				ex: (for i in {1..20}; do curl 10.101.209.36:30002; echo; done)

	NodePort
		- This service is most primitive way to get the external traffic directed to our applications 
		  running inside the cluster in pods.
		- Automatically a ClusterIP will also be created internally.

		NodePort = ClusterIP + a port mapping to the all the nodes ips. 		

		- If we wont specify any port while creating nodeport, k8s will Automatically asigns a random port 
		  between 30000 - 32767

	Load Balancer 
		- This service links to external cloud loadbalancers to the cluster.
		- This type of services are used by cloud providers (EKS, AKS, GKS) and it is completely 
		  depends on cloud provides.
		- K8S is providing a better alternative for this service which is called Ingress.

Statefull Applications 
	- User session data is saved at the server side.
	- if server goes down, it is difficult to transfer the session data to other server. 
	- This type of application will not work, if we want to implement autoscaling.
	
Stateless Applications
	- user session-data is never saved at the server side.
	- using a common authentication gateway / client token method to validate the users 
	  once for multiple microservices.	
		
https://medium.com/tech-tajawal/microservice-authentication-and-authorization-solutions-e0e5e74b248a		

Monolothic and Microservice architecture 

	Monolothic architecture
		- A monolothic application has a single code base with multiple modules in it.
		- It is a single build for entire application.
		- To make minor changes to application, we need to re-build and re-deploy the 
		  complete application.
		- scaling is very challenging.
			
	Microservice architecture 
		- A microservice application is composed of small (micro) services. 
		- Each service will have a different code base.
		- Application are divided into as small as possible sub applications called services
		  which are independent to each other which are called loosely coupled.	
		- Each service can be managed separately and it is deployable separately.
		- Services need not to share same technology stack or frameworks.		 

StatefullSet 
	- StatefullSet = Deployment + sticky identity for each and every pod 
	- Unlike a deployemnt a StatefullSet maintains a sticky identity for each and every pod.


Headless service 
	- If we don't need the default loadbalancing capability of services nor the single IP to service we use StatefullSet 
	- using Headless service we can get all the target pod ips, if we do nslookup.
	- It is created by sepcifying 'none' for ClusterIP
	- Headless service is usually used with StatefullSet controller.    

To check app is running 
	telnet 10.102.174.193 30002

namespace 	